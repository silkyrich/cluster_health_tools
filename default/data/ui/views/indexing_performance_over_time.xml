<form>
  <label>Indexing performance over time</label>
  <init>
    <eval token="seconds_for_bin">if((round(relative_time(now(), $time.latest$)-relative_time(now(), $time.earliest$))/$time_resolution$)&lt;30,30,round((relative_time(now(), $time.latest$)-relative_time(now(), $time.earliest$))/$time_resolution$))</eval>
  </init>
  <fieldset submitButton="false">
    <input type="time" token="time">
      <label></label>
      <default>
        <earliest>-4h@m</earliest>
        <latest>now</latest>
      </default>
      <change>
        <eval token="seconds_for_bin">if((round(relative_time(now(), $time.latest$)-relative_time(now(), $time.earliest$))/$time_resolution$)&lt;30,30,round((relative_time(now(), $time.latest$)-relative_time(now(), $time.earliest$))/$time_resolution$))</eval>
      </change>
    </input>
    <input type="dropdown" token="time_resolution">
      <label>Chart resolution</label>
      <choice value="100">Crude</choice>
      <choice value="250">Low</choice>
      <choice value="500">Medium</choice>
      <choice value="750">High</choice>
      <choice value="999">Ultra</choice>
      <default>500</default>
      <change>
        <eval token="seconds_for_bin">if((round(relative_time(now(), $time.latest$)-relative_time(now(), $time.earliest$))/$time_resolution$)&lt;30,30,round((relative_time(now(), $time.latest$)-relative_time(now(), $time.earliest$))/$time_resolution$))</eval>
      </change>
      
    </input>
  </fieldset>
  <row>
    <panel>
      <title>RT indexing (refreshes very 30 seconds) we want this to be mostly flat and the stdev is low</title>
      <chart>
        <search>
          <progress>
            <eval token="seconds_for_bin">if((round(relative_time(now(), $time.latest$)-relative_time(now(), $time.earliest$))/$time_resolution$)&lt;30,30,round((relative_time(now(), $time.latest$)-relative_time(now(), $time.earliest$))/$time_resolution$))</eval>
          </progress>
          <query>| rest /services/server/introspection/indexer 
| sort - splunk_server 
| eventstats stdev(average_KBps) avg(average_KBps) 
| join splunk_server 
    [| rest /services/server/info 
    | where server_roles="indexer"] 
| table splunk_server average_KBps 
| eventstats stdev(average_KBps) avg(average_KBps)</query>
          <earliest>0</earliest>
          <latest></latest>
          <refresh>30</refresh>
          <refreshType>delay</refreshType>
        </search>
        <option name="charting.chart">column</option>
        <option name="charting.chart.overlayFields">avg(average_KBps),stdev(average_KBps)</option>
        <option name="height">328</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <title>Aggregate performance of the cluster + the stdev. We want the stdev to be very low</title>
      <chart>
        <search>
          <query>index=_internal 
    [| rest /services/server/info 
    | where server_roles="indexer" 
    | fields + splunk_server 
    | eval search="host=\"".splunk_server."\"" 
    | stats values(search) as search 
    | eval search="(".mvjoin(search, " OR ").")" 
    | fields + search ] TERM(group=thruput) TERM(name=thruput) 
| bin span=$seconds_for_bin$sec _time 
| stats sum(instantaneous_kbps) as instantaneous_kbps by host _time 
| timechart stdev(instantaneous_kbps) avg(instantaneous_kbps) span=$seconds_for_bin$sec</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">line</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">all</option>
        <option name="charting.layout.splitSeries">1</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.placement">right</option>
        <option name="height">812</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <title>Blocking queues on indexers, we don't want this to happen has it creates uneven load. Blocking is starting at indexing which implies not enough IO for the indexing + search load</title>
      <input type="dropdown" token="queue">
        <label>Select blocking queue</label>
        <choice value="aeq">aeq</choice>
        <choice value="aggqueue">aggqueue</choice>
        <choice value="aq">aq</choice>
        <choice value="auditqueue">auditqueue</choice>
        <choice value="exec">exec</choice>
        <choice value="fschangemanager_queue">fschangemanager_queue</choice>
        <choice value="indexqueue">indexqueue</choice>
        <choice value="nullqueue">nullqueue</choice>
        <choice value="parsingqueue">parsingqueue</choice>
        <choice value="splunktcpin">splunktcpin</choice>
        <choice value="stashparsing">stashparsing</choice>
        <choice value="structuredparsingqueue">structuredparsingqueue</choice>
        <choice value="tcpin_queue">tcpin_queue</choice>
        <choice value="typingqueue">typingqueue</choice>
        <default>indexqueue</default>
      </input>
      <chart>
        <search>
          <query>index=_internal 
    [| rest /services/server/info 
    | where server_roles="indexer" 
    | fields + splunk_server 
    | eval search="host=\"".splunk_server."\"" 
    | stats values(search) as search 
    | eval search="(".mvjoin(search, " OR ").")" 
    | fields + search ] TERM(name=$queue$) TERM(blocked=true) sourcetype=splunkd 
| timechart span=$seconds_for_bin$sec limit=0 count by host 
| foreach * 
    [| eval &lt;&lt;FIELD&gt;&gt;=if('&lt;&lt;FIELD&gt;&gt;'=0,0,1)]</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">column</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">all</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.placement">right</option>
        <option name="height">446</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <chart>
        <title>Indexing delay of the indexers internal logs, should be about 2-5 seconds when healthy</title>
        <search>
          <query>(index=_internal OR index=core_splunk_internal) 
    [| rest /services/server/info 
    | where server_roles="indexer" 
    | fields + splunk_server 
    | eval search="host=\"".splunk_server."\"" 
    | stats values(search) as search 
    | eval search="(".mvjoin(search, " OR ").")" 
    | fields + search ]
    sourcetype=splunkd source="*metrics.log" 
| eval indexing_delay=_indextime-_time 
| eval _time=_indextime 
| timechart limit=0 span=$seconds_for_bin$sec max(indexing_delay) by host</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
        </search>
        <option name="charting.axisY.scale">log</option>
        <option name="charting.chart">line</option>
        <option name="height">543</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <title>Number of connections coming into the indexers, this needs to be high for good statistical randomness</title>
      <chart>
        <search>
          <query>(index=_internal OR index=core_splunk_internal) 
    [| rest /services/server/info 
    | where server_roles="indexer" 
    | fields + splunk_server 
    | eval search="host=\"".splunk_server."\"" 
    | stats values(search) as search 
    | eval search="(".mvjoin(search, " OR ").")" 
    | fields + search ] TERM(eventtype=connect_done) 
| timechart limit=0 span=$seconds_for_bin$sec count by host 
| eval sum=0 
| foreach * 
    [| eval sum=if(isnull('&lt;&lt;FIELD&gt;&gt;'),sum,sum+'&lt;&lt;FIELD&gt;&gt;')]</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
        </search>
        <option name="charting.axisY2.enabled">1</option>
        <option name="charting.chart">line</option>
        <option name="charting.chart.overlayFields">sum</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="height">439</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <chart>
        <search>
          <query>| tstats count where index=_internal sourcetype=splunkd TERM(name=thruput) (TERM(group=thruput) NOT(TERM(ingest_pipe*)) OR (TERM(ingest_pipe=0))) 
    [| rest /services/server/info 
    | where server_roles="indexer" 
    | fields + splunk_server 
    | eval search="host=\"".splunk_server."\"" 
    | stats values(search) as search 
    | eval search="(".mvjoin(search, " OR ").")" 
    | fields + search ] by _time host span=$seconds_for_bin$sec 
| rex field=host "^(?&lt;short_name&gt;[^\.]+)+\." 
| timechart limit=0 count span=$seconds_for_bin$sec by short_name 
| eval active_indexers=0 
| foreach * 
    [| eval active_indexers=if(isnull('&lt;&lt;FIELD&gt;&gt;') OR "&lt;&lt;FIELD&gt;&gt;"="active_indexers",active_indexers,active_indexers+1)]</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
        </search>
        <option name="charting.axisY2.enabled">1</option>
        <option name="charting.chart">line</option>
        <option name="charting.chart.overlayFields">active_indexers</option>
        <option name="charting.drilldown">none</option>
        <option name="height">349</option>
        <option name="refresh.display">progressbar</option>
      </chart>
    </panel>
  </row>
</form>
